# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2017-09-01 01:31+0000\n"
"PO-Revision-Date: 2017-09-25 04:48+0900\n"
"Last-Translator: Ayanokoji Takasi <ayanokoji.takesi@gmail.com>\n"
"Language-Team:\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: stmt.texi.orig:21 stmt.texi.orig:22
#, no-wrap
msgid "Statements"
msgstr "Statements"

#. type: cindex
#: stmt.texi.orig:23
#, no-wrap
msgid "statements"
msgstr "statements"

#. type: Plain text
#: stmt.texi.orig:27
msgid ""
"Statements may be a simple constant expression or a complicated list of "
"nested loops and conditional statements."
msgstr "命令文シンプルな定数式、ネストされたループの複雑なリスト、条件文などです。"

#. type: Plain text
#: stmt.texi.orig:35
msgid ""
"@dfn{Control statements} such as @code{if}, @code{while}, and so on control "
"the flow of execution in Octave programs.  All the control statements start "
"with special keywords such as @code{if} and @code{while}, to distinguish "
"them from simple expressions.  Many control statements contain other "
"statements; for example, the @code{if} statement contains another statement "
"which may or may not be executed."
msgstr "@code{if}、@code{while}などの制御文は、Octaveプログラムの実行において、フロー制御を行います。制御文は、単なる式と区別するために、すべて@code{if}、@code{while}などの特殊キーワードで始まります。制御文の多くは他の命令文を含みます。たとえば@code{if}文は、それが実行されるか、されないかは別として、他の命令文を含みます。"

#. type: cindex
#: stmt.texi.orig:36
#, no-wrap
msgid "@code{end} statement"
msgstr "@code{end} statement"

#. type: Plain text
#: stmt.texi.orig:45
msgid ""
"Each control statement has a corresponding @dfn{end} statement that marks "
"the end of the control statement.  For example, the keyword @code{endif} "
"marks the end of an @code{if} statement, and @code{endwhile} marks the end "
"of a @code{while} statement.  You can use the keyword @code{end} anywhere a "
"more specific end keyword is expected, but using the more specific keywords "
"is preferred because if you use them, Octave is able to provide better "
"diagnostics for mismatched or missing end tokens."
msgstr "制御文は、その制御文の終わりをマークするために、対応する@dfn{end}文をもちます。たとえば、キーワード@code{endif}は@code{if}文の終わりをマークし、@code{endwhile}は@code{while}文の終わりをマークします。これらの特定的なendキーワードを使える場所ではキーワード@code{end}も使うことができますが、、より特定的なキーワードを使用することにより、Octaveはendトークンのミスマッチや欠落にたいして、より良い診断情報を提供できます。"

#. type: Plain text
#: stmt.texi.orig:49
msgid ""
"The list of statements contained between keywords like @code{if} or "
"@code{while} and the corresponding end statement is called the @dfn{body} of "
"a control statement."
msgstr "命令文のリストには@code{if}や@code{while}のようなキーワードから、制御文の@dfn{ボディー}から呼び出される対応するend命令が含まれます。"

#. type: menuentry
#: stmt.texi.orig:61
msgid "The if Statement::"
msgstr "The if Statement::"

#. type: menuentry
#: stmt.texi.orig:61
msgid "The switch Statement::"
msgstr "The switch Statement::"

#. type: menuentry
#: stmt.texi.orig:61
msgid "The while Statement::"
msgstr "The while Statement::"

#. type: menuentry
#: stmt.texi.orig:61
msgid "The do-until Statement::"
msgstr "The do-until Statement::"

#. type: menuentry
#: stmt.texi.orig:61
msgid "The for Statement::"
msgstr "The for Statement::"

#. type: menuentry
#: stmt.texi.orig:61
msgid "The break Statement::"
msgstr "The break Statement::"

#. type: menuentry
#: stmt.texi.orig:61
msgid "The continue Statement::"
msgstr "The continue Statement::"

#. type: menuentry
#: stmt.texi.orig:61
msgid "The unwind_protect Statement::"
msgstr "The unwind_protect Statement::"

#. type: menuentry
#: stmt.texi.orig:61
msgid "The try Statement::"
msgstr "The try Statement::"

#. type: section
#: stmt.texi.orig:61 stmt.texi.orig:869 stmt.texi.orig:870
#, no-wrap
msgid "Continuation Lines"
msgstr "Continuation Lines"

#. type: section
#: stmt.texi.orig:63 stmt.texi.orig:64
#, no-wrap
msgid "The if Statement"
msgstr "The if Statement"

#. type: cindex
#: stmt.texi.orig:65
#, no-wrap
msgid "@code{if} statement"
msgstr "@code{if} statement"

#. type: cindex
#: stmt.texi.orig:66
#, no-wrap
msgid "@code{else} statement"
msgstr "@code{else} statement"

#. type: cindex
#: stmt.texi.orig:67
#, no-wrap
msgid "@code{elseif} statement"
msgstr "@code{elseif} statement"

#. type: cindex
#: stmt.texi.orig:68
#, no-wrap
msgid "@code{endif} statement"
msgstr "@code{endif} statement"

#. type: Plain text
#: stmt.texi.orig:73
msgid ""
"The @code{if} statement is Octave's decision-making statement.  There are "
"three basic forms of an @code{if} statement.  In its simplest form, it looks "
"like this:"
msgstr "@code{if}文は、Octaveにおける意思決定のための命令文です。@code{if}文には、3つの形式があります。もっとも簡単なのは、以下のような形式です:"

#. type: group
#: stmt.texi.orig:79
#, no-wrap
msgid ""
"if (@var{condition})\n"
"  @var{then-body}\n"
"endif\n"
msgstr ""
"if (@var{condition})\n"
"  @var{then-body}\n"
"endif\n"

#. type: Plain text
#: stmt.texi.orig:86
msgid ""
"@var{condition} is an expression that controls what the rest of the "
"statement will do.  The @var{then-body} is executed only if @var{condition} "
"is true."
msgstr "@var{condition}は、残りの命令文が実行されるかを制御する式です。@var{condition}がtrueのときだけ、@var{then-body}が実行されます。"

#. type: Plain text
#: stmt.texi.orig:92
msgid ""
"The condition in an @code{if} statement is considered true if its value is "
"non-zero, and false if its value is zero.  If the value of the conditional "
"expression in an @code{if} statement is a vector or a matrix, it is "
"considered true only if it is non-empty and @emph{all} of the elements are "
"non-zero."
msgstr "@code{if}文中の条件は、値が非0のときはtrue、0のときはfalseと判定されます。@code{if}文中の条件式の値がベクターかマトリクスの場合は、それらが空でなく、@emph{すべて}の要素が非0のときだけtrueと判定されます。"

#. type: Plain text
#: stmt.texi.orig:94
msgid "The second form of an if statement looks like this:"
msgstr "if文の2つ目は以下のような形式です:"

#. type: group
#: stmt.texi.orig:102
#, no-wrap
msgid ""
"if (@var{condition})\n"
"  @var{then-body}\n"
"else\n"
"  @var{else-body}\n"
"endif\n"
msgstr ""
"if (@var{condition})\n"
"  @var{then-body}\n"
"else\n"
"  @var{else-body}\n"
"endif\n"

#. type: Plain text
#: stmt.texi.orig:108
msgid ""
"If @var{condition} is true, @var{then-body} is executed; otherwise, "
"@var{else-body} is executed."
msgstr "@var{condition}がtrueのときは@var{then-body}が実行され、それ以外は@var{else-body}が実行されます。"

#. type: Plain text
#: stmt.texi.orig:110
msgid "Here is an example:"
msgstr "以下は例です:"

#. type: group
#: stmt.texi.orig:118
#, no-wrap
msgid ""
"if (rem (x, 2) == 0)\n"
"  printf (\"x is even\\n\");\n"
"else\n"
"  printf (\"x is odd\\n\");\n"
"endif\n"
msgstr ""
"if (rem (x, 2) == 0)\n"
"  printf (\"x is even\\n\");\n"
"else\n"
"  printf (\"x is odd\\n\");\n"
"endif\n"

#. type: Plain text
#: stmt.texi.orig:125
msgid ""
"In this example, if the expression @code{rem (x, 2) == 0} is true (that is, "
"the value of @code{x} is divisible by 2), then the first @code{printf} "
"statement is evaluated, otherwise the second @code{printf} statement is "
"evaluated."
msgstr "この例では、式@code{rem (x, 2) == 0}がtrue(つまり@code{x}の値が2で割り切れる)の場合は1つ目の@code{printf}文が評価され、それ以外は2つ目の@code{printf}文が評価されます。"

#. type: Plain text
#: stmt.texi.orig:129
msgid ""
"The third and most general form of the @code{if} statement allows multiple "
"decisions to be combined in a single statement.  It looks like this:"
msgstr "@code{if}文の3つ目、そしてもっとも一般的な形式では、1つの命令文の中で、複数の判定を組み合わせることができます。これは以下のようなものです:"

#. type: group
#: stmt.texi.orig:139
#, no-wrap
msgid ""
"if (@var{condition})\n"
"  @var{then-body}\n"
"elseif (@var{condition})\n"
"  @var{elseif-body}\n"
"else\n"
"  @var{else-body}\n"
"endif\n"
msgstr ""
"if (@var{condition})\n"
"  @var{then-body}\n"
"elseif (@var{condition})\n"
"  @var{elseif-body}\n"
"else\n"
"  @var{else-body}\n"
"endif\n"

#. type: Plain text
#: stmt.texi.orig:149
msgid ""
"Any number of @code{elseif} clauses may appear.  Each condition is tested in "
"turn, and if one is found to be true, its corresponding @var{body} is "
"executed.  If none of the conditions are true and the @code{else} clause is "
"present, its body is executed.  Only one @code{else} clause may appear, and "
"it must be the last part of the statement."
msgstr "任意の数の@code{elseif}節を記述できます。各条件は順番にテストされ、trueになる条件が見つかったら、その条件に対応する@var{body}が実行されます。trueとなる条件がない場合、@code{else}節が与えられたときは、それの@var{body}が実行されます。@code{else}節は1つだけ記述でき、命令文の最後の部分に記述しなければなりません。"

#. type: Plain text
#: stmt.texi.orig:156
msgid ""
"In the following example, if the first condition is true (that is, the value "
"of @code{x} is divisible by 2), then the first @code{printf} statement is "
"executed.  If it is false, then the second condition is tested, and if it is "
"true (that is, the value of @code{x} is divisible by 3), then the second "
"@code{printf} statement is executed.  Otherwise, the third @code{printf} "
"statement is performed."
msgstr "以下の例では、1つ目の条件がtrue(つまり@code{x}の値が2で割り切れる)の場合は、1つ目の@code{printf}文が実行されます。falseの場合は2つ目の条件がテストされ、それがtrue(つまり@code{x}の値が3で割り切れる)の場合は、2つ目の@code{printf}文が実行されます。それ以外は、3つ目の@code{printf}文が実行されます。"

#. type: group
#: stmt.texi.orig:166
#, no-wrap
msgid ""
"if (rem (x, 2) == 0)\n"
"  printf (\"x is even\\n\");\n"
"elseif (rem (x, 3) == 0)\n"
"  printf (\"x is odd and divisible by 3\\n\");\n"
"else\n"
"  printf (\"x is odd\\n\");\n"
"endif\n"
msgstr ""
"if (rem (x, 2) == 0)\n"
"  printf (\"x is even\\n\");\n"
"elseif (rem (x, 3) == 0)\n"
"  printf (\"x is odd and divisible by 3\\n\");\n"
"else\n"
"  printf (\"x is odd\\n\");\n"
"endif\n"

#. type: Plain text
#: stmt.texi.orig:174
msgid ""
"Note that the @code{elseif} keyword must not be spelled @code{else if}, as "
"is allowed in Fortran.  If it is, the space between the @code{else} and "
"@code{if} will tell Octave to treat this as a new @code{if} statement within "
"another @code{if} statement's @code{else} clause.  For example, if you write"
msgstr "キーワード@code{elseif}は、Fortranのように@code{else if}と記述してはならないことに注意してください。そのように記述した場合、@code{else}と@code{if}の間のスペースは、別の@code{if}文の@code{else}節にある新たな@code{if}命令文としてそれを扱うようOctaveに指示します。たとえば、以下のように記述した場合"

#. type: group
#: stmt.texi.orig:182
#, no-wrap
msgid ""
"if (@var{c1})\n"
"  @var{body-1}\n"
"else if (@var{c2})\n"
"  @var{body-2}\n"
"endif\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:193
msgid ""
"Octave will expect additional input to complete the first @code{if} "
"statement.  If you are using Octave interactively, it will continue to "
"prompt you for additional input.  If Octave is reading this input from a "
"file, it may complain about missing or mismatched @code{end} statements, or, "
"if you have not used the more specific @code{end} statements (@code{endif}, "
"@code{endfor}, etc.), it may simply produce incorrect results, without "
"producing any warning messages."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:196
msgid ""
"It is much easier to see the error if we rewrite the statements above like "
"this,"
msgstr ""

#. type: group
#: stmt.texi.orig:205
#, no-wrap
msgid ""
"if (@var{c1})\n"
"  @var{body-1}\n"
"else\n"
"  if (@var{c2})\n"
"    @var{body-2}\n"
"  endif\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:211
msgid ""
"using the indentation to show how Octave groups the statements.  "
"@xref{Functions and Scripts}."
msgstr ""

#. type: section
#: stmt.texi.orig:212 stmt.texi.orig:213
#, no-wrap
msgid "The switch Statement"
msgstr ""

#. type: cindex
#: stmt.texi.orig:214
#, no-wrap
msgid "@code{switch} statement"
msgstr ""

#. type: cindex
#: stmt.texi.orig:215
#, no-wrap
msgid "@code{case} statement"
msgstr ""

#. type: cindex
#: stmt.texi.orig:216
#, no-wrap
msgid "@code{otherwise} statement"
msgstr ""

#. type: cindex
#: stmt.texi.orig:217
#, no-wrap
msgid "@code{endswitch} statement"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:222
msgid ""
"It is very common to take different actions depending on the value of one "
"variable.  This is possible using the @code{if} statement in the following "
"way"
msgstr ""

#. type: group
#: stmt.texi.orig:232
#, no-wrap
msgid ""
"if (X == 1)\n"
"  do_something ();\n"
"elseif (X == 2)\n"
"  do_something_else ();\n"
"else\n"
"  do_something_completely_different ();\n"
"endif\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:239
msgid ""
"This kind of code can however be very cumbersome to both write and "
"maintain.  To overcome this problem Octave supports the @code{switch} "
"statement.  Using this statement, the above example becomes"
msgstr ""

#. type: group
#: stmt.texi.orig:250
#, no-wrap
msgid ""
"switch (X)\n"
"  case 1\n"
"    do_something ();\n"
"  case 2\n"
"    do_something_else ();\n"
"  otherwise\n"
"    do_something_completely_different ();\n"
"endswitch\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:259
msgid ""
"This code makes the repetitive structure of the problem more explicit, "
"making the code easier to read, and hence maintain.  Also, if the variable "
"@code{X} should change its name, only one line would need changing compared "
"to one line per case when @code{if} statements are used."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:261
msgid "The general form of the @code{switch} statement is"
msgstr ""

#. type: group
#: stmt.texi.orig:270
#, no-wrap
msgid ""
"switch (@var{expression})\n"
"  case @var{label}\n"
"    @var{command_list}\n"
"  case @var{label}\n"
"    @var{command_list}\n"
"  @dots{}\n"
"\n"
msgstr ""

#. type: group
#: stmt.texi.orig:274
#, no-wrap
msgid ""
"  otherwise\n"
"    @var{command_list}\n"
"endswitch\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:284
msgid ""
"where @var{label} can be any expression.  However, duplicate @var{label} "
"values are not detected, and only the @var{command_list} corresponding to "
"the first match will be executed.  For the @code{switch} statement to be "
"meaningful at least one @code{case @var{label} @var{command_list}} clause "
"must be present, while the @code{otherwise @var{command_list}} clause is "
"optional."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:289
msgid ""
"If @var{label} is a cell array the corresponding @var{command_list} is "
"executed if @emph{any} of the elements of the cell array match "
"@var{expression}.  As an example, the following program will print "
"@samp{Variable is either 6 or 7}."
msgstr ""

#. type: group
#: stmt.texi.orig:299
#, no-wrap
msgid ""
"A = 7;\n"
"switch (A)\n"
"  case @{ 6, 7 @}\n"
"    printf (\"variable is either 6 or 7\\n\");\n"
"  otherwise\n"
"    printf (\"variable is neither 6 nor 7\\n\");\n"
"endswitch\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:305
msgid ""
"As with all other specific @code{end} keywords, @code{endswitch} may be "
"replaced by @code{end}, but you can get better diagnostics if you use the "
"specific forms."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:311
msgid ""
"One advantage of using the @code{switch} statement compared to using "
"@code{if} statements is that the @var{label}s can be strings.  If an "
"@code{if} statement is used it is @emph{not} possible to write"
msgstr ""

#. type: example
#: stmt.texi.orig:314
#, no-wrap
msgid "if (X == \"a string\") # This is NOT valid\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:321
msgid ""
"since a character-to-character comparison between @code{X} and the string "
"will be made instead of evaluating if the strings are equal.  This "
"special-case is handled by the @code{switch} statement, and it is possible "
"to write programs that look like this"
msgstr ""

#. type: group
#: stmt.texi.orig:329
#, no-wrap
msgid ""
"switch (X)\n"
"  case \"a string\"\n"
"    do_something\n"
"  @dots{}\n"
"endswitch\n"
msgstr ""

#. type: subsection
#: stmt.texi.orig:334 stmt.texi.orig:336 stmt.texi.orig:337
#, no-wrap
msgid "Notes for the C Programmer"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:342
msgid ""
"The @code{switch} statement is also available in the widely used C "
"programming language.  There are, however, some differences between the "
"statement in Octave and C"
msgstr ""

#. type: itemize
#: stmt.texi.orig:347
msgid ""
"Cases are exclusive, so they don't `fall through' as do the cases in the "
"@code{switch} statement of the C language."
msgstr ""

#. type: itemize
#: stmt.texi.orig:352
msgid ""
"The @var{command_list} elements are not optional.  Making the list optional "
"would have meant requiring a separator between the label and the command "
"list.  Otherwise, things like"
msgstr ""

#. type: group
#: stmt.texi.orig:358
#, no-wrap
msgid ""
"switch (foo)\n"
"  case (1) -2\n"
"  @dots{}\n"
msgstr ""

#. type: itemize
#: stmt.texi.orig:363
msgid "would produce surprising results, as would"
msgstr ""

#. type: group
#: stmt.texi.orig:371
#, no-wrap
msgid ""
"switch (foo)\n"
"  case (1)\n"
"  case (2)\n"
"    doit ();\n"
"  @dots{}\n"
msgstr ""

#. type: itemize
#: stmt.texi.orig:378
msgid ""
"particularly for C programmers.  If @code{doit()} should be executed if "
"@var{foo} is either @code{1} or @code{2}, the above code should be written "
"with a cell array like this"
msgstr ""

#. type: group
#: stmt.texi.orig:385
#, no-wrap
msgid ""
"switch (foo)\n"
"  case @{ 1, 2 @}\n"
"    doit ();\n"
"  @dots{}\n"
msgstr ""

#. type: section
#: stmt.texi.orig:390 stmt.texi.orig:391
#, no-wrap
msgid "The while Statement"
msgstr ""

#. type: cindex
#: stmt.texi.orig:392
#, no-wrap
msgid "@code{while} statement"
msgstr ""

#. type: cindex
#: stmt.texi.orig:393
#, no-wrap
msgid "@code{endwhile} statement"
msgstr ""

#. type: cindex
#: stmt.texi.orig:394
#, no-wrap
msgid "loop"
msgstr ""

#. type: cindex
#: stmt.texi.orig:395
#, no-wrap
msgid "body of a loop"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:399
msgid ""
"In programming, a @dfn{loop} means a part of a program that is (or at least "
"can be) executed two or more times in succession."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:407
msgid ""
"The @code{while} statement is the simplest looping statement in Octave.  It "
"repeatedly executes a statement as long as a condition is true.  As with the "
"condition in an @code{if} statement, the condition in a @code{while} "
"statement is considered true if its value is non-zero, and false if its "
"value is zero.  If the value of the conditional expression in a @code{while} "
"statement is a vector or a matrix, it is considered true only if it is "
"non-empty and @emph{all} of the elements are non-zero."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:409
msgid "Octave's @code{while} statement looks like this:"
msgstr ""

#. type: group
#: stmt.texi.orig:415
#, no-wrap
msgid ""
"while (@var{condition})\n"
"  @var{body}\n"
"endwhile\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:422 stmt.texi.orig:487
msgid ""
"Here @var{body} is a statement or list of statements that we call the "
"@dfn{body} of the loop, and @var{condition} is an expression that controls "
"how long the loop keeps running."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:429
msgid ""
"The first thing the @code{while} statement does is test @var{condition}.  If "
"@var{condition} is true, it executes the statement @var{body}.  After "
"@var{body} has been executed, @var{condition} is tested again, and if it is "
"still true, @var{body} is executed again.  This process repeats until "
"@var{condition} is no longer true.  If @var{condition} is initially false, "
"the body of the loop is never executed."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:432 stmt.texi.orig:490
msgid ""
"This example creates a variable @code{fib} that contains the first ten "
"elements of the Fibonacci sequence."
msgstr ""

#. type: group
#: stmt.texi.orig:441
#, no-wrap
msgid ""
"fib = ones (1, 10);\n"
"i = 3;\n"
"while (i <= 10)\n"
"  fib (i) = fib (i-1) + fib (i-2);\n"
"  i++;\n"
"endwhile\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:446
msgid "Here the body of the loop contains two statements."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:454
msgid ""
"The loop works like this: first, the value of @code{i} is set to 3.  Then, "
"the @code{while} tests whether @code{i} is less than or equal to 10.  This "
"is the case when @code{i} equals 3, so the value of the @code{i}-th element "
"of @code{fib} is set to the sum of the previous two values in the sequence.  "
"Then the @code{i++} increments the value of @code{i} and the loop repeats.  "
"The loop terminates when @code{i} reaches 11."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:458
msgid ""
"A newline is not required between the condition and the body; but using one "
"makes the program clearer unless the body is very simple."
msgstr ""

#. type: section
#: stmt.texi.orig:459 stmt.texi.orig:460
#, no-wrap
msgid "The do-until Statement"
msgstr ""

#. type: cindex
#: stmt.texi.orig:461
#, no-wrap
msgid "@code{do-until} statement"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:472
msgid ""
"The @code{do-until} statement is similar to the @code{while} statement, "
"except that it repeatedly executes a statement until a condition becomes "
"true, and the test of the condition is at the end of the loop, so the body "
"of the loop is always executed at least once.  As with the condition in an "
"@code{if} statement, the condition in a @code{do-until} statement is "
"considered true if its value is non-zero, and false if its value is zero.  "
"If the value of the conditional expression in a @code{do-until} statement is "
"a vector or a matrix, it is considered true only if it is non-empty and "
"@emph{all} of the elements are non-zero."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:474
msgid "Octave's @code{do-until} statement looks like this:"
msgstr ""

#. type: group
#: stmt.texi.orig:480
#, no-wrap
msgid ""
"do\n"
"  @var{body}\n"
"until (@var{condition})\n"
msgstr ""

#. type: group
#: stmt.texi.orig:499
#, no-wrap
msgid ""
"fib = ones (1, 10);\n"
"i = 2;\n"
"do\n"
"  i++;\n"
"  fib (i) = fib (i-1) + fib (i-2);\n"
"until (i == 10)\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:505
msgid ""
"A newline is not required between the @code{do} keyword and the body; but "
"using one makes the program clearer unless the body is very simple."
msgstr ""

#. type: section
#: stmt.texi.orig:506 stmt.texi.orig:507
#, no-wrap
msgid "The for Statement"
msgstr ""

#. type: cindex
#: stmt.texi.orig:508
#, no-wrap
msgid "@code{for} statement"
msgstr ""

#. type: cindex
#: stmt.texi.orig:509
#, no-wrap
msgid "@code{endfor} statement"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:513
msgid ""
"The @code{for} statement makes it more convenient to count iterations of a "
"loop.  The general form of the @code{for} statement looks like this:"
msgstr ""

#. type: group
#: stmt.texi.orig:519
#, no-wrap
msgid ""
"for @var{var} = @var{expression}\n"
"  @var{body}\n"
"endfor\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:528
msgid ""
"where @var{body} stands for any statement or list of statements, "
"@var{expression} is any valid expression, and @var{var} may take several "
"forms.  Usually it is a simple variable name or an indexed variable.  If the "
"value of @var{expression} is a structure, @var{var} may also be a vector "
"with two elements.  @xref{Looping Over Structure Elements}, below."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:537
msgid ""
"The assignment expression in the @code{for} statement works a bit "
"differently than Octave's normal assignment statement.  Instead of assigning "
"the complete result of the expression, it assigns each column of the "
"expression to @var{var} in turn.  If @var{expression} is a range, a row "
"vector, or a scalar, the value of @var{var} will be a scalar each time the "
"loop body is executed.  If @var{var} is a column vector or a matrix, "
"@var{var} will be a column vector each time the loop body is executed."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:541
msgid ""
"The following example shows another way to create a vector containing the "
"first ten elements of the Fibonacci sequence, this time using the @code{for} "
"statement:"
msgstr ""

#. type: group
#: stmt.texi.orig:548
#, no-wrap
msgid ""
"fib = ones (1, 10);\n"
"for i = 3:10\n"
"  fib (i) = fib (i-1) + fib (i-2);\n"
"endfor\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:559
msgid ""
"This code works by first evaluating the expression @code{3:10}, to produce a "
"range of values from 3 to 10 inclusive.  Then the variable @code{i} is "
"assigned the first element of the range and the body of the loop is executed "
"once.  When the end of the loop body is reached, the next value in the range "
"is assigned to the variable @code{i}, and the loop body is executed again.  "
"This process continues until there are no more elements to assign."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:562
msgid ""
"Within Octave is it also possible to iterate over matrices or cell arrays "
"using the @code{for} statement.  For example consider"
msgstr ""

#. type: group
#: stmt.texi.orig:573
#, no-wrap
msgid ""
"disp (\"Loop over a matrix\")\n"
"for i = [1,3;2,4]\n"
"  i\n"
"endfor\n"
"disp (\"Loop over a cell array\")\n"
"for i = @{1,\"two\";\"three\",4@}\n"
"  i\n"
"endfor\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:582
msgid ""
"In this case the variable @code{i} takes on the value of the columns of the "
"matrix or cell matrix.  So the first loop iterates twice, producing two "
"column vectors @code{[1;2]}, followed by @code{[3;4]}, and likewise for the "
"loop over the cell array.  This can be extended to loops over "
"multi-dimensional arrays.  For example:"
msgstr ""

#. type: group
#: stmt.texi.orig:589
#, no-wrap
msgid ""
"a = [1,3;2,4]; c = cat (3, a, 2*a);\n"
"for i = c\n"
"  i\n"
"endfor\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:597
msgid ""
"In the above case, the multi-dimensional matrix @var{c} is reshaped to a "
"two-dimensional matrix as @code{reshape (c, rows (c), prod (size "
"(c)(2:end)))} and then the same behavior as a loop over a two dimensional "
"matrix is produced."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:604
msgid ""
"Although it is possible to rewrite all @code{for} loops as @code{while} "
"loops, the Octave language has both statements because often a @code{for} "
"loop is both less work to type and more natural to think of.  Counting the "
"number of iterations is very common in loops and it can be easier to think "
"of this counting as part of looping rather than as something to do inside "
"the loop."
msgstr ""

#. type: subsection
#: stmt.texi.orig:607 stmt.texi.orig:609 stmt.texi.orig:610
#, no-wrap
msgid "Looping Over Structure Elements"
msgstr ""

#. type: cindex
#: stmt.texi.orig:611
#, no-wrap
msgid "structure elements, looping over"
msgstr ""

#. type: cindex
#: stmt.texi.orig:612
#, no-wrap
msgid "looping over structure elements"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:616
msgid ""
"A special form of the @code{for} statement allows you to loop over all the "
"elements of a structure:"
msgstr ""

#. type: group
#: stmt.texi.orig:622
#, no-wrap
msgid ""
"for [ @var{val}, @var{key} ] = @var{expression}\n"
"  @var{body}\n"
"endfor\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:630
msgid ""
"In this form of the @code{for} statement, the value of @var{expression} must "
"be a structure.  If it is, @var{key} and @var{val} are set to the name of "
"the element and the corresponding value in turn, until there are no more "
"elements.  For example:"
msgstr ""

#. type: group
#: stmt.texi.orig:640
#, no-wrap
msgid ""
"x.a = 1\n"
"x.b = [1, 2; 3, 4]\n"
"x.c = \"string\"\n"
"for [val, key] = x\n"
"  key\n"
"  val\n"
"endfor\n"
"\n"
msgstr ""

#. type: group
#: stmt.texi.orig:651
#, no-wrap
msgid ""
"     @print{} key = a\n"
"     @print{} val = 1\n"
"     @print{} key = b\n"
"     @print{} val =\n"
"     @print{} \n"
"     @print{}   1  2\n"
"     @print{}   3  4\n"
"     @print{} \n"
"     @print{} key = c\n"
"     @print{} val = string\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:657
msgid ""
"The elements are not accessed in any particular order.  If you need to cycle "
"through the list in a particular way, you will have to use the function "
"@code{fieldnames} and sort the list yourself."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:662
msgid ""
"The @var{key} variable may also be omitted.  If it is, the brackets are also "
"optional.  This is useful for cycling through the values of all the "
"structure elements when the names of the elements do not need to be known."
msgstr ""

#. type: section
#: stmt.texi.orig:663 stmt.texi.orig:664
#, no-wrap
msgid "The break Statement"
msgstr ""

#. type: cindex
#: stmt.texi.orig:665
#, no-wrap
msgid "@code{break} statement"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:672
msgid ""
"The @code{break} statement jumps out of the innermost @code{while}, "
"@code{do-until}, or @code{for} loop that encloses it.  The @code{break} "
"statement may only be used within the body of a loop.  The following example "
"finds the smallest divisor of a given integer, and also identifies prime "
"numbers:"
msgstr ""

#. type: group
#: stmt.texi.orig:688
#, no-wrap
msgid ""
"num = 103;\n"
"div = 2;\n"
"while (div*div <= num)\n"
"  if (rem (num, div) == 0)\n"
"    break;\n"
"  endif\n"
"  div++;\n"
"endwhile\n"
"if (rem (num, div) == 0)\n"
"  printf (\"Smallest divisor of %d is %d\\n\", num, div)\n"
"else\n"
"  printf (\"%d is prime\\n\", num);\n"
"endif\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:696
msgid ""
"When the remainder is zero in the first @code{while} statement, Octave "
"immediately @dfn{breaks out} of the loop.  This means that Octave proceeds "
"immediately to the statement following the loop and continues processing.  "
"(This is very different from the @code{exit} statement which stops the "
"entire Octave program.)"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:700
msgid ""
"Here is another program equivalent to the previous one.  It illustrates how "
"the @var{condition} of a @code{while} statement could just as well be "
"replaced with a @code{break} inside an @code{if}:"
msgstr ""

#. type: group
#: stmt.texi.orig:716
#, no-wrap
msgid ""
"num = 103;\n"
"div = 2;\n"
"while (1)\n"
"  if (rem (num, div) == 0)\n"
"    printf (\"Smallest divisor of %d is %d\\n\", num, div);\n"
"    break;\n"
"  endif\n"
"  div++;\n"
"  if (div*div > num)\n"
"    printf (\"%d is prime\\n\", num);\n"
"    break;\n"
"  endif\n"
"endwhile\n"
msgstr ""

#. type: section
#: stmt.texi.orig:719 stmt.texi.orig:720
#, no-wrap
msgid "The continue Statement"
msgstr ""

#. type: cindex
#: stmt.texi.orig:721
#, no-wrap
msgid "@code{continue} statement"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:729
msgid ""
"The @code{continue} statement, like @code{break}, is used only inside "
"@code{while}, @code{do-until}, or @code{for} loops.  It skips over the rest "
"of the loop body, causing the next cycle around the loop to begin "
"immediately.  Contrast this with @code{break}, which jumps out of the loop "
"altogether.  Here is an example:"
msgstr ""

#. type: group
#: stmt.texi.orig:734
#, no-wrap
msgid ""
"# print elements of a vector of random\n"
"# integers that are even.\n"
"\n"
msgstr ""

#. type: group
#: stmt.texi.orig:737
#, no-wrap
msgid ""
"# first, create a row vector of 10 random\n"
"# integers with values between 0 and 100:\n"
"\n"
msgstr ""

#. type: group
#: stmt.texi.orig:739
#, no-wrap
msgid ""
"vec = round (rand (1, 10) * 100);\n"
"\n"
msgstr ""

#. type: group
#: stmt.texi.orig:741
#, no-wrap
msgid ""
"# print what we're interested in:\n"
"\n"
msgstr ""

#. type: group
#: stmt.texi.orig:748
#, no-wrap
msgid ""
"for x = vec\n"
"  if (rem (x, 2) != 0)\n"
"    continue;\n"
"  endif\n"
"  printf (\"%d\\n\", x);\n"
"endfor\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:754
msgid ""
"If one of the elements of @var{vec} is an odd number, this example skips the "
"print statement for that element, and continues back to the first statement "
"in the loop."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:758
msgid ""
"This is not a practical example of the @code{continue} statement, but it "
"should give you a clear understanding of how it works.  Normally, one would "
"probably write the loop like this:"
msgstr ""

#. type: group
#: stmt.texi.orig:766
#, no-wrap
msgid ""
"for x = vec\n"
"  if (rem (x, 2) == 0)\n"
"    printf (\"%d\\n\", x);\n"
"  endif\n"
"endfor\n"
msgstr ""

#. type: section
#: stmt.texi.orig:769 stmt.texi.orig:770
#, no-wrap
msgid "The unwind_protect Statement"
msgstr ""

#. type: cindex
#: stmt.texi.orig:771
#, no-wrap
msgid "@code{unwind_protect} statement"
msgstr ""

#. type: code{#1}
#: stmt.texi.orig:772
#, no-wrap
msgid "unwind_protect_cleanup"
msgstr ""

#. type: code{#1}
#: stmt.texi.orig:773
#, no-wrap
msgid "end_unwind_protect"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:777
msgid ""
"Octave supports a limited form of exception handling modeled after the "
"unwind-protect form of Lisp."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:779
msgid "The general form of an @code{unwind_protect} block looks like this:"
msgstr ""

#. type: group
#: stmt.texi.orig:787
#, no-wrap
msgid ""
"unwind_protect\n"
"  @var{body}\n"
"unwind_protect_cleanup\n"
"  @var{cleanup}\n"
"end_unwind_protect\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:794
msgid ""
"where @var{body} and @var{cleanup} are both optional and may contain any "
"Octave expressions or commands.  The statements in @var{cleanup} are "
"guaranteed to be executed regardless of how control exits @var{body}."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:800
msgid ""
"This is useful to protect temporary changes to global variables from "
"possible errors.  For example, the following code will always restore the "
"original value of the global variable @code{frobnosticate} even if an error "
"occurs in the first part of the @code{unwind_protect} block."
msgstr ""

#. type: group
#: stmt.texi.orig:810
#, no-wrap
msgid ""
"save_frobnosticate = frobnosticate;\n"
"unwind_protect\n"
"  frobnosticate = true;\n"
"  @dots{}\n"
"unwind_protect_cleanup\n"
"  frobnosticate = save_frobnosticate;\n"
"end_unwind_protect\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:819
msgid ""
"Without @code{unwind_protect}, the value of @var{frobnosticate} would not be "
"restored if an error occurs while evaluating the first part of the "
"@code{unwind_protect} block because evaluation would stop at the point of "
"the error and the statement to restore the value would not be executed."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:822
msgid ""
"In addition to unwind_protect, Octave supports another form of exception "
"handling, the @code{try} block."
msgstr ""

#. type: section
#: stmt.texi.orig:824 stmt.texi.orig:825
#, no-wrap
msgid "The try Statement"
msgstr ""

#. type: cindex
#: stmt.texi.orig:826
#, no-wrap
msgid "@code{try} statement"
msgstr ""

#. type: code{#1}
#: stmt.texi.orig:827
#, no-wrap
msgid "catch"
msgstr ""

#. type: code{#1}
#: stmt.texi.orig:828
#, no-wrap
msgid "end_try_catch"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:831
msgid "The original form of a @code{try} block looks like this:"
msgstr ""

#. type: group
#: stmt.texi.orig:839
#, no-wrap
msgid ""
"try\n"
"  @var{body}\n"
"catch\n"
"  @var{cleanup}\n"
"end_try_catch\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:846
msgid ""
"where @var{body} and @var{cleanup} are both optional and may contain any "
"Octave expressions or commands.  The statements in @var{cleanup} are only "
"executed if an error occurs in @var{body}."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:852
msgid ""
"No warnings or error messages are printed while @var{body} is executing.  If "
"an error does occur during the execution of @var{body}, @var{cleanup} can "
"use the functions @code{lasterr} or @code{lasterror} to access the text of "
"the message that would have been printed, as well as its identifier.  The "
"alternative form,"
msgstr ""

#. type: group
#: stmt.texi.orig:860
#, no-wrap
msgid ""
"try\n"
"  @var{body}\n"
"catch @var{err}\n"
"  @var{cleanup}\n"
"end_try_catch\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:867
msgid ""
"will automatically store the output of @code{lasterror} in the structure "
"@var{err}.  @xref{Errors and Warnings}, for more information about the "
"@code{lasterr} and @code{lasterror} functions."
msgstr ""

#. type: cindex
#: stmt.texi.orig:871
#, no-wrap
msgid "continuation lines"
msgstr ""

#. type: cindex
#: stmt.texi.orig:872
#, no-wrap
msgid "@code{...} continuation marker"
msgstr ""

#. type: cindex
#: stmt.texi.orig:873
#, no-wrap
msgid "@code{\\} continuation marker"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:880
msgid ""
"In the Octave language, most statements end with a newline character and you "
"must tell Octave to ignore the newline character in order to continue a "
"statement from one line to the next.  Lines that end with the characters "
"@code{...} are joined with the following line before they are divided into "
"tokens by Octave's parser.  For example, the lines"
msgstr ""

#. type: group
#: stmt.texi.orig:886
#, no-wrap
msgid ""
"x = long_variable_name ...\n"
"    + longer_variable_name ...\n"
"    - 42\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:891
msgid "form a single statement."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:894
msgid ""
"Any text between the continuation marker and the newline character is "
"ignored.  For example, the statement"
msgstr ""

#. type: group
#: stmt.texi.orig:900
#, no-wrap
msgid ""
"x = long_variable_name ...    # comment one\n"
"    + longer_variable_name ...comment two\n"
"    - 42                      # last comment\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:905
msgid "is equivalent to the one shown above."
msgstr ""

#. type: Plain text
#: stmt.texi.orig:909
msgid ""
"Inside double-quoted string constants, the character @code{\\} has to be "
"used as continuation marker.  The @code{\\} must appear at the end of the "
"line just before the newline character:"
msgstr ""

#. type: group
#: stmt.texi.orig:914
#, no-wrap
msgid ""
"s = \"This text starts in the first line \\\n"
"and is continued in the second line.\"\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:921
msgid ""
"Input that occurs inside parentheses can be continued to the next line "
"without having to use a continuation marker.  For example, it is possible to "
"write statements like"
msgstr ""

#. type: group
#: stmt.texi.orig:929
#, no-wrap
msgid ""
"if (fine_dining_destination == on_a_boat\n"
"    || fine_dining_destination == on_a_train)\n"
"  seuss (i, will, not, eat, them, sam, i, am, i,\n"
"         will, not, eat, green, eggs, and, ham);\n"
"endif\n"
msgstr ""

#. type: Plain text
#: stmt.texi.orig:933
msgid "without having to add to the clutter with continuation markers."
msgstr ""
